const { db } = require('../firebase');
const aiRecipeService = require('./aiRecipeService');

class InventoryService {
  
  /**
   * Creates a default recipe for a menu item if one doesn't exist.
   * Triggered asynchronously after menu item creation.
   */
  async createDefaultRecipe(restaurantId, menuItemId, itemName, description, userId = 'system') {
    try {
      // Check if recipe already exists for this item
      const existingRecipe = await db.collection('recipes')
        .where('restaurantId', '==', restaurantId)
        .where('menuItemId', '==', menuItemId)
        .limit(1)
        .get();

      if (!existingRecipe.empty) {
        console.log(`‚ÑπÔ∏è Recipe already exists for ${itemName}`);
        return;
      }

      // Generate ingredients via AI
      const ingredients = await aiRecipeService.generateRecipe(itemName, description);

      if (ingredients.length === 0) {
        console.log(`‚ö†Ô∏è No ingredients generated for ${itemName}`);
        return;
      }

      // Save to Firestore
      const recipeData = {
        restaurantId,
        menuItemId,
        menuItemName: itemName,
        name: `${itemName} (Auto-Generated)`,
        description: 'AI Generated Default Recipe',
        ingredients: ingredients.map(ing => ({
            inventoryItemName: ing.name,
            quantity: ing.quantity,
            unit: ing.unit,
            // We don't have inventoryItemId yet, will be matched during deduction or manually mapped later
            inventoryItemId: null 
        })),
        isAutoGenerated: true,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date(),
        createdBy: userId
      };

      await db.collection('recipes').add(recipeData);
      console.log(`‚úÖ Created default AI recipe for ${itemName} with ${ingredients.length} ingredients`);

    } catch (error) {
      console.error(`‚ùå Failed to create default recipe for ${itemName}:`, error);
    }
  }

  /**
   * Deducts inventory based on an order.
   * Triggered asynchronously after order placement.
   */
  async deductInventoryForOrder(restaurantId, orderId, orderItems) {
    console.log(`üìâ Processing inventory deduction for Order ${orderId}`);
    
    try {
      if (!orderItems || orderItems.length === 0) return;

      // Create batch using the db instance
      const batch = db.batch();
      let hasUpdates = false;

      // 1. Load all inventory items for the restaurant for matching
      const inventorySnapshot = await db.collection('inventory')
        .where('restaurantId', '==', restaurantId)
        .get();
      
      const inventoryItems = [];
      inventorySnapshot.forEach(doc => {
        inventoryItems.push({ id: doc.id, ...doc.data(), ref: doc.ref });
      });

      // 2. Process each ordered item
      for (const item of orderItems) {
        const qtySold = item.quantity;
        
        // Find recipe for this menu item
        // Note: Using 'menuItemId' which we expect to be stored on the recipe
        const recipeQuery = await db.collection('recipes')
            .where('restaurantId', '==', restaurantId)
            .where('menuItemId', '==', item.menuItemId)
            .limit(1)
            .get();

        if (recipeQuery.empty) {
            console.log(`‚ö†Ô∏è No recipe found for item: ${item.name} (${item.menuItemId}). Skipping deduction.`);
            continue;
        }

        const recipe = recipeQuery.docs[0].data();
        
        // 3. Process ingredients in recipe
        for (const ingredient of recipe.ingredients) {
            const qtyNeeded = ingredient.quantity * qtySold;
            
            // Try to find matching inventory item
            // First check if linked by ID
            let inventoryItem = null;
            if (ingredient.inventoryItemId) {
                inventoryItem = inventoryItems.find(i => i.id === ingredient.inventoryItemId);
            }

            // Fallback: Fuzzy name match
            if (!inventoryItem) {
                const targetName = ingredient.inventoryItemName.toLowerCase();
                inventoryItem = inventoryItems.find(i => 
                    i.name.toLowerCase() === targetName || 
                    i.name.toLowerCase().includes(targetName) ||
                    targetName.includes(i.name.toLowerCase())
                );
            }

            if (inventoryItem) {
                // Perform simple unit conversion if possible (basic implementation)
                // Assuming units match for now or are simple metric (g/kg, ml/l)
                let deductionAmount = qtyNeeded;
                
                // Basic Unit Handling (Simple scaling)
                if (ingredient.unit === 'g' && inventoryItem.unit === 'kg') {
                    deductionAmount = qtyNeeded / 1000;
                } else if (ingredient.unit === 'ml' && inventoryItem.unit === 'l') {
                    deductionAmount = qtyNeeded / 1000;
                }

                const newStock = (inventoryItem.currentStock || 0) - deductionAmount;
                
                // Update Inventory
                batch.update(inventoryItem.ref, {
                    currentStock: newStock,
                    updatedAt: new Date()
                });

                // Log Transaction
                const transactionRef = db.collection('inventoryTransactions').doc();
                batch.set(transactionRef, {
                    restaurantId,
                    inventoryItemId: inventoryItem.id,
                    inventoryItemName: inventoryItem.name,
                    type: 'DEDUCTION',
                    source: 'ORDER',
                    referenceId: orderId, // Order ID
                    quantityChange: -deductionAmount,
                    unit: inventoryItem.unit,
                    date: new Date(),
                    notes: `Order of ${qtySold}x ${item.name}`
                });

                hasUpdates = true;
                // Update local array to reflect changes if same ingredient used multiple times in order
                inventoryItem.currentStock = newStock;
            } else {
                console.log(`‚ö†Ô∏è Could not find inventory item for ingredient: ${ingredient.inventoryItemName}`);
            }
        }
      }

      if (hasUpdates) {
        await batch.commit();
        console.log(`‚úÖ Inventory updated for Order ${orderId}`);
      }

    } catch (error) {
      console.error(`‚ùå Error in inventory deduction for Order ${orderId}:`, error);
    }
  }

  /**
   * Handles "Bulk Production" (e.g., Making 10kg Gravy).
   * Deducts raw ingredients, Adds to "Prepped" inventory.
   */
  async logProductionRun(restaurantId, recipeId, batchQuantity, userId) {
      // Implementation for future use
  }
}

module.exports = new InventoryService();


